//
//  MemoryTest.hpp
//  PlaygroundCpp
//
//  Created by Stephen Gowen on 11/9/17.
//  Copyright Â© 2017 Stephen Gowen. All rights reserved.
//

#pragma once

#include <vector>
#include <string>

#include <vector/Extension.hpp>

class MemoryTest
{
public:
    static void test()
    {
        std::vector<std::string> testVector;
        testVector.push_back("this is a test");
        testVector.push_back("this is a test as well");
        testVector.push_back("this is a test also");
        testVector.push_back("this is a test too");
        testVector.push_back("this is a test man");
        
        void* pointer1 = &testVector[3];
        
        std::string test = testVector[3];
        void* pointer2 = &test;
        
        std::string& test2 = testVector[3];
        void* pointer3 = &test2;
        
        std::cout << "pointer1 " << pointer1 << std::endl;
        std::cout << "pointer2 " << pointer2 << std::endl;
        std::cout << "pointer3 " << pointer3 << std::endl;
        
        std::string* stringP = new std::string("Why would you ever want a pointer to a string huh?");
        std::string stringDeref = *stringP;
        stringDeref += " You wouldn't!";
        std::string& stringDerefRef = *stringP;
        
        std::cout << "stringP " << stringP << std::endl;
        std::cout << "&stringDeref " << &stringDeref << std::endl;
        std::cout << "&stringDerefRef " << &stringDerefRef << std::endl;
        
        testStringConstructor();
        
        std::string OptionString = std::string("imagertemp=-10.0");
        testStringCopyToken(OptionString);
        
        std::string OptionString2 = std::string("");
        testStringCopyToken(OptionString2);
        
        testSizeOf();
    }
    
    struct DataInput
    {
        const unsigned char* cursor;
        const unsigned char* end;
    };
    
    static unsigned char readByte(DataInput* input)
    {
        return *input->cursor++;
    }
    
    static int readVarint(DataInput* input, bool optimizePositive)
    {
        unsigned char b = readByte(input);
        int value = b & 0x7F;
        if (b & 0x80)
        {
            b = readByte(input);
            value |= (b & 0x7F) << 7;
            if (b & 0x80)
            {
                b = readByte(input);
                value |= (b & 0x7F) << 14;
                if (b & 0x80)
                {
                    b = readByte(input);
                    value |= (b & 0x7F) << 21;
                    if (b & 0x80) value |= (readByte(input) & 0x7F) << 28;
                }
            }
        }
        
        if (!optimizePositive)
        {
            value = (((unsigned int)value >> 1) ^ -(value & 1));
        }
        
        return value;
    }
    
    static char* readString(DataInput* input)
    {
        int length = readVarint(input, true);
        char* string;
        if (length == 0)
        {
            return 0;
        }
        string = MALLOC(char, length);
        memcpy(string, input->cursor, length - 1);
        input->cursor += length - 1;
        string[length - 1] = '\0';
        return string;
    }
    
    static unsigned char* readFile(const char* path, int* length)
    {
        unsigned char *data;
        FILE *file = fopen(path, "rb");
        if (!file) return 0;
        
        fseek(file, 0, SEEK_END);
        *length = (int)ftell(file);
        fseek(file, 0, SEEK_SET);
        
        data = MALLOC(unsigned char, *length);
        fread(data, 1, *length, file);
        fclose(file);
        
        return data;
    }
    
    static std::string readStuff(const unsigned char* binary, const int length)
    {
        DataInput* input = CALLOC(DataInput, 1);
        input->cursor = binary;
        input->end = binary + length;
        
        char* char_hash = readString(input);
        std::string hash = std::string(char_hash);
        FREE(char_hash);
        
        return hash;
    }
    
    static void testStringConstructor()
    {
        int length;
        const unsigned char* binary = readFile("test.txt", &length);
        
        std::string stringThatWeRead = readStuff(binary, length);
        
        printf("stringThatWeRead: %s", stringThatWeRead.c_str());
        
        FREE(binary);
    }
    
#define IMAGER_TEMP_OPTION "imagertemp"
#define INTEGRATION_TIME_OPTION "integrationtime"
    
    static void testStringCopyToken(std::string OptionString)
    {
        float ImagerTemp = 0.0f;
        bool SetImagerTemp = false;
        bool AutoIntegration = false;
        const float DEFAULT_INTEGRATION_TIME = 1.0f;
        float IntegrationTime = DEFAULT_INTEGRATION_TIME;
        if (OptionString.length() > 0)
        {
            char *dup = strdup(OptionString.c_str());
            char* Token = strtok(dup, ",");
            
            while(Token != NULL)
            {
                std::size_t found = std::string(Token).find(IMAGER_TEMP_OPTION);
                if(found!=std::string::npos)
                {
                    if(strlen(Token) > strlen(IMAGER_TEMP_OPTION)+2 && Token[strlen(IMAGER_TEMP_OPTION)] == '=')
                    {
                        SetImagerTemp = true;
                        ImagerTemp = atof(Token+strlen(IMAGER_TEMP_OPTION)+1);
                    }
                }
                found = std::string(Token).find(INTEGRATION_TIME_OPTION);
                if(found!=std::string::npos)
                {
                    if(strlen(Token) > strlen(INTEGRATION_TIME_OPTION)+2 && Token[strlen(INTEGRATION_TIME_OPTION)] == '=')
                    {
                        const char* parameter = Token+strlen(INTEGRATION_TIME_OPTION)+1;
                        float temp = atof(parameter);
                        if(temp >= 0.01f && temp <= 10.0f)IntegrationTime = temp;
                        if(temp == 0.0f && !strcmp(parameter, "auto"))
                        {
                            IntegrationTime = 0.01f; //Start point for AutoIntegration
                            AutoIntegration = true;
                        }
                    }
                }
                Token = strtok (NULL, ",");
            }
            
            free(dup);
        }
    }
    
    static void testSizeOf()
    {
        static const float emulated_cycloexane[] = {800,680,555,613,730,690,635,632,649,750,733,481,435,616,783,943,947,904,683,457,440,432,464,449,343,314,365,500,683,728,733,720,699,596,518,530,577,686,722,685,768,918,703,393,186,28,342,590,607,609,586,504,364,377,470,604,748,585,406,253,188,414,597,709,661,467,442,501,677,879,810,742,789,872,1065,1213,1288,1378,1481,1534,1563,1474,1360,1213,1075,1006,893,654,484,416,436,529,597,654,592,507,497,518,753,871,676,540,489,474,490,506,522,608,705,781,847,858,892,989,1076,1149,1134,1053,1136,1284,1406,1522,1498,1493,1594,1670,1687,1621,1451,1297,1156,1050,957,782,596,555,538,653,739,763,727,619,592,620,586,531,507,483,340,230,279,343,440,511,551,480,336,340,394,513,636,669,669,525,385,250,318,611,733,748,627,462,554,664,650,634,611,621,699,681,561,573,663,676,668,645,630,736,823,832,844,862,838,773,626,435,387,379,623,868,875,807,470,260,270,379,583,705,782,851,918,872,819,769,727,709,644,500,387,302,364,498,566,618,638,659,687,705,690,679,678,724,812,763,647,663,707,808,889,800,688,510,365,269,250,297,341,382,403,421,527,627,668,686,640,676,828,986,1147,1151,1087,865,614,489,393,474,582,760,842,795,747,698,647,595,480,353,664,902,712,564,519,518,576,631,686,602,464,545,658,683,686,575,494,482,560,749,867,935,873,764,768,788,863,926,925,891,782,729,741,775,822,860,894,975,1054,949,843,733,675,724,726,676,668,686,621,529,533,551,647,701,573,460,376,339,354,463,628,764,890,930,960,953,950,962,956,918,920,965,964,937,786,600,642,698,683,676,695,720,758,789,813,844,878,877,868,853,840,858,861,816,777,749,661,518,552,676,786,893,945,980,883,780,657,603,660,677,660,629,593,582,576,706,817,730,654,611,603,647,701,761,791,806,792,771,846,910,866,813,734,709,763,794,808,837,874,837,786,798,822,912,914,684,582,658,712,750,705,627,727,860,697,552,523,535,646,659,539,524,586,713,863,788,678,696,719,763,758,635,552,516,545,618,682,742,642,525,679,793,704,669,758,794,766,799,871,922,965,918,864,958,1036,1039,1029,994,1066,1260,1417,1549,1672,1792,2143,2522,2954,3494,4503,5706,7299,9337,11863,14722,17784,20950,24148,28440,32937,39129,45758,54140,63003,72781,82635,92568,95235,93691,80329,63588,46636,30197,21181,13330,9825,6975,5312,4148,3482,2878,2310,2147,2094,1924,1752,1651,1549,1444,1389,1419,1369,1242,1066,862,821,820,896,970,979,955,825,746,752,726,672,660,670,707,749,696,657,780,861,816,782,766,630,390,423,585,585,552,621,704,875,930,657,418,233,205,307,404,499,592,683,681,668,596,547,560,584,623,616,574,561,560,720,910,784,678,710,715,650,607,592,618,675,604,483,390,304,589,820,742,696,732,657,439,303,227,210,215,385,577,671,749,752,757,766,721,610,628,735,753,739,844,959,870,816,934,1011,997,1020,1087,1089,1046,961,861,845,833,710,639,803,878,772,628,441,313,221,176,147,337,539,516,504,541,577,609,627,631,590,521,567,647,716,779,778,787,837,824,697,626,612,684,804,759,668,581,501,500,482,404,379,447,490,508,545,590,660,736,736,736,768,781,731,632,452,505,773,816,745,732,731,650,576,599,652,796,923,1020,1197,1442,1700,1963,2205,2442,2745,3073,3585,4139,4816,5566,6425,7077,7556,8438,9504,10629,11766,12537,13257,13668,13945,13851,13508,12808,11742,10382,9135,7936,6917,5930,5047,4195,3533,2974,2684,2401,2130,1923,1765,1672,1606,1590,1583,1425,1251,990,801,790,778,765,743,715,782,886,866,828,839,853,877,818,564,454,521,521,474,516,589,650,709,733,759,787,774,667,614,625,648,678,662,630,698,766,533,374,548,651,605,472,242,284,498,543,535,520,505,504,509,539,544,499,472,463,442,414,483,582,679,771,779,742,533,439,563,628,631,576,487,568,696,626,551,615,672,707,707,641,632,676,657,602,526,444,399,354,298,282,401,532,682,813,924,971,985,1121,1287,1682,2082,2411,2772,3233,3464,3325,3023,2575,2093,1595,1370,1205,892,609,630,611,475,388,375,485,699,688,573,670,812,796,767,685,601,514,386,197,301,645,809,894,880,847,644,483,620,711,677,640,600,617,678,435,66,257,545,527,529,659,754,762,726,633,581,561,688,872,651,369,346,369,653,822,721,643,594,589,616,628,635,666,698,636,613,786,875,776,683,599,641,767,925,1093,1013,906,959,972,798,715,824,984,1201,1468,1767,2054,2338,2597,2862,3351,3883,4600,5329,6083,6762,7359,7935,8497,8820,9069,8664,8184,7510,6843,6203,5528,4784,4091,3449,3012,2694,2341,1978,1820,1678,1506,1375,1400,1351,1169,988,809,793,866,816,732,708,690,671,642,581,542,542,521,481,480,500,646,824,738,655,757,816,733,712,793,792,716,668,634,657,692,694,691,661,657,733,754,688,616,540,624,782,666,490,627,745,652,672,1021,1210,1163,1047,874,936,1103,1162,1200,1176,1158,1202,1228,1210,1152,1038,984,976,899,793,772,765,708,660,672,665,610,554,497,566,728,768,759,644,512,581,640,642,678,798,859,846,939,1108,1039,880,590,289,526,701,552,482,594,644,620,645,704,689,649,758,882,828,775,723,712,789,878,980,913,737,701,711,686,656,574,530,655,729,698,737,854,891,877,1017,1204,1232,1248,1349,1433,1449,1498,1610,1739,1886,1982,2049,2146,2252,2681,3146,3736,4282,4661,5038,5411,5862,6392,6456,6259,5997,5717,5351,4961,4354,3760,3209,2787,2587,2337,2039,1761,1495,1485,1541,1473,1400,1348,1300,1268,1285,1385,1253,908,753,693,711,746,662,568,434,384,600,726,708,692,679,742,841,735,584,585,598,676,708,606,511,424,537,818,959,1037,945,818,700,607,699,752,701,663,644,731,904,850,698,650,621,616,615,643,649,596,530,446,533,749,716,581,664,785,828,828,578,430,531,542,435,399,414,423,429,453,479,519,539,454,431,551,612,599,541,454,535,676,645,596,745,859,796,758,779,773,736,628,472,526,651,756,851,752,691,794,816,669,607,642,784,992,894,699,532,380,496,613,732,745,550,495,591,598,553,474,387,380,386,476,561,633,727,866,922,892,799,670,677,723,657,581,490,465,678,751,577,357,93,288,733,801,771,537,325,523,625,402,353,598,684,622,683,807,935,1063,1029,977,853,724,576,550,720,838,909,795,591,504,443,486,525,496,488,538,524,410,428,559,551,480,497,531,592,645,635,663,799,799,600,549,619,613,573,762,994,697,429,423,392,299,255,281,404,602,614,549,437,316,422,531,657,714,593,531,549,508,424,482,596,570,524,605,662,580,534,573,630,711,695,612,621,665,662,648,475,368,596,694,500,446,560,606,607,647,701,658,606,625,640,632,631,644,671,713,693,634,549,455,565,688,568,507,700,773,603,559,655,683,669,531,356,479,628,693,717,577,510,584,572,471,493,585,520,409,212,50,472,787,702,625,563,580,675,755,826,764,667,701,742,749,742,685,590,427,455,666,797,888,884,857,822,786,738,712,758,674,378,346,555,637,655,590,505,580,653,642,670,814,882,829,772,711,653,597,651,729,725,726,784,837,874,857,761,819,1005,846,534,599,738,777,812,833,847,844,840,834,690,437,455,588,685,775,626,508,601,727,935,977,792,756,831,884,930,976,1021,630,362,802,1044,809,736,871,875,785,842,954,892,806,805,806,811,806,781,762,752,720,673,740,847,805,741,638,590,813,896,677,653,856,900,842,807,781,864,954,877,812,800,791,789,833,928,853,671,681,750,629,497,548,615,740,784,668,643,713,787,865,817,733,801,873,801,706,515,484,746,954,1108,1028,817,688,581,820,1058,951,842,728,611,486,527,726,813,839,844,843,677,529,691,828,882,905,876,840,799,779,771,832,909,832,745,628,599,843,907,686,640,748,756,717,608,484,692,862,620,497,726,852,820,791,763,813,899,774,607,683,756,768,777,779,766,731,735,769,872,1006,852,645,791,891,666,545,699,790,795,881,1028,977,845,938,1068};
        
        int spectrum_len = sizeof(emulated_cycloexane) / sizeof(float);
        printf("emulated spectrum_len %d", spectrum_len);
        
        assert(spectrum_len == 1701);
    }
    
private:
    MemoryTest();
    ~MemoryTest();
    MemoryTest(const MemoryTest&);
    MemoryTest& operator=(const MemoryTest&);
};
